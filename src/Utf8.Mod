MODULE Utf8;
(** Module for UTF-8 manipulation, encoding and decoding *)

TYPE
  CHAR8 = SHORTCHAR;
  SHORTCHAR* = CHAR8;

VAR
  Done-: BOOLEAN; (** TRUE on successful operation, FALSE on error *)

(** Convert UTF-8 string `in` to a UTF-16 string `out` *)
PROCEDURE Decode*(IN in: ARRAY OF SHORTCHAR; OUT out: ARRAY OF CHAR);
VAR i, j, val, lim: INTEGER; c: SHORTCHAR;
BEGIN Done := TRUE; c := in[0]; i := 1; j := 0; lim := LEN(out) - 1;
  WHILE Done & (i < LEN(in)) & (c # 0X) & (j < lim) DO
    IF c < 80X THEN out[j] := c; INC(j)
    ELSIF (c < 0E0X) & (i < LEN(in) - 2) THEN val := ORD(c) - 192;
      IF val < 0 THEN out := in$; Done := FALSE END;
      c := in[i]; INC(i); val := val * 64 + ORD(c) - 128;
      IF (c < 80X) OR (c >= 0E0X) THEN out := in$; Done := FALSE END;
      out[j] := CHR(val); INC(j)
    ELSIF (c < 0F0X) & (i < LEN(in) - 3) THEN val := ORD(c) - 224;
      c := in[i]; INC(i); val := val * 64 + ORD(c) - 128;
      IF (c < 80X) OR (c >= 0E0X) THEN out := in$; Done := FALSE END;
      c := in[i]; INC(i); val := val * 64 + ORD(c) - 128;
      IF (c < 80X) OR (c >= 0E0X) THEN out := in$; Done := FALSE END;
      out[j] := CHR(val); INC(j)
    ELSE out := in$; Done := FALSE
    END;
    c := in[i]; INC(i)
  END;
  out[j] := 0X;
  IF c # 0X THEN Done := FALSE END
END Decode;

(** Converts at most `inLen` first characters of UTF-16 string `in` to a
    UTF-8 string `out` and sets `outLen` to the number of parsed UTF-16
    characters.
     Done is set to TRUE on success and FALSE in case of an error *)
PROCEDURE EncodeEx*(IN in: ARRAY OF CHAR; inLen: INTEGER;
    OUT out: ARRAY OF SHORTCHAR; OUT outLen: INTEGER);
VAR i, j, val, lim: INTEGER;
BEGIN Done := TRUE; i := 0; j := 0; lim := LEN(out) - 1;
  IF inLen < 0 THEN inLen := LEN(in) END;
  WHILE Done & (i # inLen) & (in[i] # 0X) & (j < lim) DO
    val := ORD(in[i]); INC(i);
    IF val < 128 THEN
      out[j] := SHORT(CHR(val)); INC(j)
    ELSIF (val < 2048) & (j < lim - 1) THEN
      out[j] := SHORT(CHR(val DIV 64 + 192)); INC(j);
      out[j] := SHORT(CHR(val MOD 64 + 128)); INC(j)
    ELSIF j < lim - 2 THEN
      out[j] := SHORT(CHR(val DIV 4096 + 224)); INC(j); 
      out[j] := SHORT(CHR(val DIV 64 MOD 64 + 128)); INC(j);
      out[j] := SHORT(CHR(val MOD 64 + 128)); INC(j)
    ELSE Done := FALSE
    END
  END;
  out[j] := 0X; outLen := j;
  IF (i # inLen) & (in[i] # 0X) THEN Done := FALSE END
END EncodeEx;

(** Converts UTF-16A string `in` to a UTF-8 string `out`.
     Done is set to TRUE on success and FALSE in case of an error *)
PROCEDURE Encode*(IN in: ARRAY OF CHAR; OUT out: ARRAY OF SHORTCHAR);
VAR n: INTEGER;
BEGIN EncodeEx(in, -1, out, n)
END Encode;

(** Converts the first UTF-8-encoded character from `s` to an UTF-16
    character and returns it *)
PROCEDURE DecodeChar*(IN s: ARRAY OF (*!FIXME SHORT?*)CHAR): CHAR;
VAR i, x, c: INTEGER;
BEGIN c := ORD(s[0]);
  IF c > 80H THEN x := ORD(s[1]) MOD 64; (* Not 1 byte *)
    IF c DIV 32 = 6 THEN (* 2 bytes *)
      c := c MOD 32 * 64 + x
    ELSIF c DIV 16 = 14 THEN (* 3 bytes *)
      c := (c MOD 16 * 64 + x) * 64 + ORD(s[2]) MOD 64
    ELSIF c DIV 8 = 30 THEN (* 4 bytes *)
      c := ((c MOD 8 * 64 + x) * 64 + ORD(s[2]) MOD 64) * 64 + ORD(s[3]) MOD 64
    ELSE c := 0
    END
  END ;
RETURN CHR(c) END DecodeChar;

(** Converts a single UTF-16 character `c` to an UTF-8 string `s` and
    puts in `len` the number of generated bytes *)
PROCEDURE EncodeChar*(c: CHAR; OUT s: ARRAY OF SHORTCHAR; OUT len: INTEGER);
VAR q: ARRAY 1 OF CHAR;
BEGIN q[0] := c; EncodeEx(q, 1, s, len)
END EncodeChar;

(** Returns a SHORTCHAR character value with the given ordinal value.
     This is essentially CHR(n) if it would return a SHORTCHAR *)
PROCEDURE ShortChr*(n: INTEGER): SHORTCHAR;
BEGIN RETURN SHORT(CHR(n)) END ShortChr;

(** Converts a CHAR value `c` to a SHORTCHAR value (may truncate it)
    and returns it *)
PROCEDURE Short*(c: CHAR): SHORTCHAR;
BEGIN RETURN SHORT(c) END Short;

(** Converts a SHORTCHAR value `c` to a CHAR value and returns it *)
PROCEDURE Long*(c: SHORTCHAR): CHAR;
BEGIN RETURN LONG(c) END Long;

END Utf8.
